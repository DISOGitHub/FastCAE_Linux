// This file has been automatically generated from resource file src/Shaders/DeclarationsImpl.glsl

static const char Shaders_DeclarationsImpl_glsl[] =
  "\n"
  "//! @file DeclarationsImpl.glsl includes implementation of common functions and properties accessors\n"
  "#if defined(FRAGMENT_SHADER)\n"
  "//! Output color (and coverage for accumulation by OIT algorithm).\n"
  "void occSetFragColor (in vec4 theColor)\n"
  "{\n"
  "#if defined(OCC_ALPHA_TEST)\n"
  "  if (theColor.a < occAlphaCutoff) discard;\n"
  "#endif\n"
  "#if defined(OCC_WRITE_WEIGHT_OIT_COVERAGE)\n"
  "  float aWeight     = theColor.a * clamp (1e+2 * pow (1.0 - gl_FragCoord.z * occOitDepthFactor, 3.0), 1e-2, 1e+2);\n"
  "  occFragCoverage.r = theColor.a * aWeight;\n"
  "  occFragColor      = vec4 (theColor.rgb * theColor.a * aWeight, theColor.a);\n"
  "#else\n"
  "  occFragColor = theColor;\n"
  "#endif\n"
  "}\n"
  "#endif\n"
  "\n"
  "#if defined(THE_MAX_LIGHTS) && (THE_MAX_LIGHTS > 0)\n"
  "// arrays of light sources\n"
  "uniform               vec4 occLightSources[THE_MAX_LIGHTS * 4]; //!< packed light sources parameters\n"
  "uniform THE_PREC_ENUM int occLightSourcesTypes[THE_MAX_LIGHTS]; //!< packed light sources types\n"
  "#endif\n"
  "\n"
  "#if defined(THE_IS_PBR)\n"
  "vec3 occDiffIBLMap (in vec3 theNormal)\n"
  "{\n"
  "  vec3 aSHCoeffs[9];\n"
  "  for (int i = 0; i < 9; ++i)\n"
  "  {\n"
  "    aSHCoeffs[i] = occTexture2D (occDiffIBLMapSHCoeffs, vec2 ((float(i) + 0.5) / 9.0, 0.0)).rgb;\n"
  "  }\n"
  "  return aSHCoeffs[0]\n"
  "\n"
  "       + aSHCoeffs[1] * theNormal.x\n"
  "	   + aSHCoeffs[2] * theNormal.y\n"
  "	   + aSHCoeffs[3] * theNormal.z\n"
  "\n"
  "	   + aSHCoeffs[4] * theNormal.x * theNormal.z\n"
  "	   + aSHCoeffs[5] * theNormal.y * theNormal.z\n"
  "	   + aSHCoeffs[6] * theNormal.x * theNormal.y\n"
  "\n"
  "	   + aSHCoeffs[7] * (3.0 * theNormal.z * theNormal.z - 1.0)\n"
  "	   + aSHCoeffs[8] * (theNormal.x * theNormal.x - theNormal.y * theNormal.y);\n"
  "}\n"
  "#endif\n"
  "\n"
  "// front and back material properties accessors\n"
  "#if defined(THE_IS_PBR)\n"
  "uniform vec4 occPbrFrontMaterial[3];\n"
  "uniform vec4 occPbrBackMaterial[3];\n"
  "\n"
  "#define MIN_ROUGHNESS 0.01\n"
  "float occRoughness (in float theNormalizedRoughness) { return theNormalizedRoughness * (1.0 - MIN_ROUGHNESS) + MIN_ROUGHNESS; }\n"
  "vec4  occPBRMaterial_Color(in bool theIsFront)     { return theIsFront ? occPbrFrontMaterial[0]     : occPbrBackMaterial[0]; }\n"
  "vec3  occPBRMaterial_Emission(in bool theIsFront)  { return theIsFront ? occPbrFrontMaterial[1].rgb : occPbrBackMaterial[1].rgb; }\n"
  "float occPBRMaterial_IOR(in bool theIsFront)       { return theIsFront ? occPbrFrontMaterial[1].w   : occPbrBackMaterial[1].w; }\n"
  "float occPBRMaterial_Metallic(in bool theIsFront)  { return theIsFront ? occPbrFrontMaterial[2].b   : occPbrBackMaterial[2].b; }\n"
  "float occPBRMaterial_NormalizedRoughness(in bool theIsFront) { return theIsFront ? occPbrFrontMaterial[2].g : occPbrBackMaterial[2].g; }\n"
  "#else\n"
  "uniform vec4 occFrontMaterial[5];\n"
  "uniform vec4 occBackMaterial[5];\n"
  "\n"
  "vec4  occFrontMaterial_Ambient(void)      { return occFrontMaterial[0]; }\n"
  "vec4  occFrontMaterial_Diffuse(void)      { return occFrontMaterial[1]; }\n"
  "vec4  occFrontMaterial_Specular(void)     { return occFrontMaterial[2]; }\n"
  "vec4  occFrontMaterial_Emission(void)     { return occFrontMaterial[3]; }\n"
  "float occFrontMaterial_Shininess(void)    { return occFrontMaterial[4].x; }\n"
  "float occFrontMaterial_Transparency(void) { return occFrontMaterial[4].y; }\n"
  "\n"
  "vec4  occBackMaterial_Ambient(void)       { return occBackMaterial[0]; }\n"
  "vec4  occBackMaterial_Diffuse(void)       { return occBackMaterial[1]; }\n"
  "vec4  occBackMaterial_Specular(void)      { return occBackMaterial[2]; }\n"
  "vec4  occBackMaterial_Emission(void)      { return occBackMaterial[3]; }\n"
  "float occBackMaterial_Shininess(void)     { return occBackMaterial[4].x; }\n"
  "float occBackMaterial_Transparency(void)  { return occBackMaterial[4].y; }\n"
  "#endif\n"
  "\n"
  "// 2D texture coordinates transformation\n"
  "vec2  occTextureTrsf_Translation(void) { return occTexTrsf2d[0].xy; }\n"
  "vec2  occTextureTrsf_Scale(void)       { return occTexTrsf2d[0].zw; }\n"
  "float occTextureTrsf_RotationSin(void) { return occTexTrsf2d[1].x; }\n"
  "float occTextureTrsf_RotationCos(void) { return occTexTrsf2d[1].y; }\n"
  "//! @endfile DeclarationsImpl.glsl\n";
